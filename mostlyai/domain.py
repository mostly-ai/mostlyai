# generated by datamodel-codegen:
#   timestamp: 2024-12-20T07:08:28+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import (
    Any,
    Dict,
    List,
    Optional,
    ClassVar,
    Literal,
    Annotated,
)
import pandas as pd
from pathlib import Path
from pydantic import field_validator
from mostlyai.client._base_utils import convert_to_base64
from pydantic import Field, RootModel

from mostlyai.client.base import CustomBaseModel


class AboutService(CustomBaseModel):
    """
    General information about the service.
    """

    version: Annotated[
        Optional[str],
        Field(description="The version number of the service.", examples=["v209"]),
    ] = None
    assistant: Annotated[
        Optional[bool],
        Field(description="A flag indicating if the assistant is enabled."),
    ] = None


class PermissionLevel(str, Enum):
    """
    The permission level of the user with respect to this resource

    - `VIEW`: The user can view and use the resource
    - `ADMIN`: The user can edit, delete and transfer ownership of the resource

    """

    view = "VIEW"
    edit = "EDIT"
    admin = "ADMIN"


class UserSettingsProfileUpdateConfig(CustomBaseModel):
    first_name: Annotated[
        Optional[str],
        Field(alias="firstName", description="First name of a user", max_length=30),
    ] = None
    last_name: Annotated[
        Optional[str],
        Field(alias="lastName", description="Last name of a user", max_length=30),
    ] = None


class UserSettingsAssistantUpdateConfig(CustomBaseModel):
    about_user_message: Annotated[
        Optional[str],
        Field(
            alias="aboutUserMessage",
            description="The instruction what the Assistant should know about the user to provide better response",
        ),
    ] = None
    about_model_message: Annotated[
        Optional[str],
        Field(
            alias="aboutModelMessage",
            description="The instruction how the Assistant should respond",
        ),
    ] = None


class Credits(CustomBaseModel):
    current: Annotated[
        Optional[float],
        Field(description="The credit balance for the current time period"),
    ] = None
    limit: Annotated[
        Optional[float],
        Field(
            description="The credit limit for the current time period. If empty, then there is no limit."
        ),
    ] = None
    period_start: Annotated[
        Optional[datetime],
        Field(
            alias="periodStart",
            description="The UTC date and time when the current time period started",
        ),
    ] = None
    period_end: Annotated[
        Optional[datetime],
        Field(
            alias="periodEnd",
            description="The UTC date and time when the current time period ends",
        ),
    ] = None


class ParallelTrainingJobs(CustomBaseModel):
    current: Annotated[
        Optional[int],
        Field(description="The number of currently running training jobs"),
    ] = None
    limit: Annotated[
        Optional[int],
        Field(
            description="The maximum number of running training jobs at any time. If empty, then there is no limit."
        ),
    ] = None


class ParallelGenerationJobs(CustomBaseModel):
    current: Annotated[
        Optional[int],
        Field(description="The number of currently running generation jobs."),
    ] = None
    limit: Annotated[
        Optional[int],
        Field(
            description="The maximum number of running generation jobs at any time. If empty, then there is no limit."
        ),
    ] = None


class UserUsage(CustomBaseModel):
    credits: Optional[Credits] = None
    parallel_training_jobs: Annotated[
        Optional[ParallelTrainingJobs], Field(alias="parallelTrainingJobs")
    ] = None
    parallel_generation_jobs: Annotated[
        Optional[ParallelGenerationJobs], Field(alias="parallelGenerationJobs")
    ] = None


class NotificationStatus(str, Enum):
    """
    The status of the notification.
    """

    unread = "UNREAD"
    read = "READ"


class NotificationType(str, Enum):
    """
    The type of the notification
    """

    resource_ready = "RESOURCE_READY"
    resource_shared = "RESOURCE_SHARED"
    resource_liked = "RESOURCE_LIKED"
    resource_failed = "RESOURCE_FAILED"


class Metadata(CustomBaseModel):
    """
    The metadata of a resource.
    """

    created_at: Annotated[
        Optional[datetime],
        Field(
            alias="createdAt",
            description="The UTC date and time when the resource has been created.\n",
            examples=["2023‐09‐07T18:40:39Z"],
        ),
    ] = None
    owner_id: Annotated[
        Optional[str],
        Field(
            alias="ownerId",
            description="The unique identifier of the owner of the entity.",
        ),
    ] = None
    owner_name: Annotated[
        Optional[str],
        Field(alias="ownerName", description="The name of the owner of the entity."),
    ] = None
    current_user_permission_level: Annotated[
        Optional[PermissionLevel], Field(alias="currentUserPermissionLevel")
    ] = None
    current_user_like_status: Annotated[
        Optional[bool],
        Field(
            alias="currentUserLikeStatus",
            description="A boolean indicating whether the user has liked the entity or not",
        ),
    ] = None
    short_lived_file_token: Annotated[
        Optional[str],
        Field(
            alias="shortLivedFileToken",
            description="An auto-generated short-lived file token (`slft`) for accessing resource artefacts.\nThe token is always restricted to a single resource, only valid for 60 minutes, and \nonly accepted by API endpoints that allow to download single files.\n",
        ),
    ] = None


class PaginatedTotalCount(RootModel[int]):
    root: Annotated[
        int, Field(description="The total number of entities within the list")
    ]


class ConnectorAccessType(str, Enum):
    """
    The access type of a connector. Either `SOURCE` or `DESTINATION`.
    """

    source = "SOURCE"
    destination = "DESTINATION"


class ConnectorType(str, Enum):
    """
    The type of a connector.

    The type determines the structure of the config, secrets and ssl parameters.

    - `MYSQL`: MySQL database
    - `POSTGRES`: PostgreSQL database
    - `MSSQL`: Microsoft SQL Server database
    - `ORACLE`: Oracle database
    - `MARIADB`: MariaDB database
    - `SNOWFLAKE`: Snowflake cloud data platform
    - `BIGQUERY`: Google BigQuery cloud data warehouse
    - `HIVE`: Apache Hive database
    - `DATABRICKS`: Databricks cloud data platform
    - `AZURE_STORAGE`: Azure Blob Storage
    - `GOOGLE_CLOUD_STORAGE`: Google Cloud Storage
    - `S3_STORAGE`: Amazon S3 Storage
    - `FILE_UPLOAD`: File upload

    """

    mysql = "MYSQL"
    postgres = "POSTGRES"
    mssql = "MSSQL"
    oracle = "ORACLE"
    mariadb = "MARIADB"
    snowflake = "SNOWFLAKE"
    bigquery = "BIGQUERY"
    hive = "HIVE"
    databricks = "DATABRICKS"
    azure_storage = "AZURE_STORAGE"
    google_cloud_storage = "GOOGLE_CLOUD_STORAGE"
    s3_storage = "S3_STORAGE"
    file_upload = "FILE_UPLOAD"


class ConnectorUsage(CustomBaseModel):
    """
    Usage statistics of a connector.
    """

    no_of_shares: Annotated[
        Optional[int],
        Field(alias="noOfShares", description="Number of shares of this connector."),
    ] = None
    no_of_generators: Annotated[
        Optional[int],
        Field(
            alias="noOfGenerators",
            description="Number of generators using this connector.",
        ),
    ] = None


class ConnectorListItem(CustomBaseModel):
    """
    Essential connector details for listings.
    """

    id: Annotated[str, Field(description="The unique identifier of a connector.")]
    name: Annotated[str, Field(description="The name of a connector.")]
    type: ConnectorType
    access_type: Annotated[ConnectorAccessType, Field(alias="accessType")]
    metadata: Metadata
    usage: Optional[ConnectorUsage] = None


class Connector(CustomBaseModel):
    """
    A connector is a connection to a data source or a data destination.

    """

    id: Annotated[str, Field(description="The unique identifier of a connector.")]
    name: Annotated[str, Field(description="The name of a connector.")]
    type: ConnectorType
    access_type: Annotated[ConnectorAccessType, Field(alias="accessType")]
    config: Optional[Dict[str, Any]] = None
    secrets: Optional[Dict[str, str]] = None
    ssl: Optional[Dict[str, str]] = None
    metadata: Optional[Metadata] = None
    usage: Optional[ConnectorUsage] = None
    table_id: Annotated[
        Optional[str],
        Field(
            alias="tableId",
            description="Optional. ID of a source table or a synthetic table, that this connector belongs to.\nIf not set, then this connector is managed independently of any generator or synthetic dataset.\n",
        ),
    ] = None
    OPEN_URL_PARTS: ClassVar[list] = ["d", "connectors"]

    def update(
        self,
        name: str | None = None,
        config: dict[str, Any] | None = None,
        secrets: dict[str, str] | None = None,
        ssl: dict[str, str] | None = None,
        test_connection: bool | None = True,
    ) -> None:
        """
        Update a connector with specific parameters.

        Args:
            name: The name of the connector.
            config (dict[str, Any], optional): Connector configuration.
            secrets (dict[str, str], optional): Secret values for the connector.
            ssl (dict[str, str], optional): SSL configuration for the connector.
            test_connection: If true, validates the connection before saving.
        """
        patch_config = ConnectorPatchConfig(
            name=name,
            config=config,
            secrets=secrets,
            ssl=ssl,
        )
        self.client._update(
            connector_id=self.id,
            config=patch_config.model_dump(exclude_none=True),
            test_connection=test_connection,
        )
        self.reload()

    def delete(self) -> None:
        """
        Delete the connector.

        Returns:
            None
        """
        return self.client._delete(connector_id=self.id)

    def locations(self, prefix: str = "") -> list:
        """
        List connector locations.

        List the available databases, schemas, tables, or folders for a connector.
        For storage connectors, this returns list of folders and files at root, respectively at `prefix` level.
        For DB connectors, this returns list of schemas (or databases for DBs without schema), respectively list of tables if `prefix` is provided.

        The formats of the locations are:

        - Cloud storage:
            - `AZURE_STORAGE`: `container/path`
            - `GOOGLE_CLOUD_STORAGE`: `bucket/path`
            - `S3_STORAGE`: `bucket/path`
        - Database:
            - `BIGQUERY`: `dataset.table`
            - `DATABRICKS`: `schema.table`
            - `HIVE`: `database.table`
            - `MARIADB`: `database.table`
            - `MSSQL`: `schema.table`
            - `MYSQL`: `database.table`
            - `ORACLE`: `schema.table`
            - `POSTGRES`: `schema.table`
            - `SNOWFLAKE`: `schema.table`

        Args:
            prefix: The prefix to filter the results by.

        Returns:
            list: A list of locations (schemas, databases, directories, etc.)."""
        return self.client._locations(connector_id=self.id, prefix=prefix)

    def schema(self, location: str) -> list[dict[str, Any]]:
        """
        Retrieve the schema of the table at a connector location.
        Please refer to `locations()` for the format of the location.

        Args:
            location: The location of the table.

        Returns:
            list[dict[str, Any]]: The retrieved schema.
        """
        return self.client._schema(connector_id=self.id, location=location)


class ConnectorConfig(CustomBaseModel):
    """
    The structures of the config, secrets and ssl parameters depend on the connector type.

    - Cloud storage:
      ```yaml
      - type: AZURE_STORAGE
        config:
          accountName: string
          clientId: string (required for auth via service principal)
          tenantId: string (required for auth via service principal)
        secrets:
          accountKey: string (required for regular auth)
          clientSecret: string (required for auth via service principal)

      - type: GOOGLE_CLOUD_STORAGE
        config:
        secrets:
          keyFile: string

      - type: S3_STORAGE
        config:
          accessKey: string
          endpointUrl: string (only needed for S3-compatible storage services other than AWS)
          sslEnabled: boolean, default: false
        secrets:
          secretKey: string
        ssl:
          caCertificate: base64-encoded string
      ```
    - Database:
      ```yaml
      - type: BIGQUERY
        config:
        secrets:
          keyFile: string

      - type: DATABRICKS
        config:
          host: string
          httpPath: string
          catalog: string
          clientId: string (required for auth via service principal)
          tenantId: string (required for auth via service principal)
        secrets:
          accessToken: string (required for regular auth)
          clientSecret: string (required for auth via service principal)

      - type: HIVE
        config:
          host: string
          port: integer, default: 10000
          username: string (required for regular auth)
          kerberosEnabled: boolean, default: false
          kerberosServicePrincipal: string (required if kerberosEnabled)
          kerberosClientPrincipal: string (optional if kerberosEnabled)
          kerberosKrb5Conf: string (required if kerberosEnabled)
          sslEnabled: boolean, default: false
        secrets:
          password: string (required for regular auth)
          kerberosKeytab: base64-encoded string (required if kerberosEnabled)
        ssl:
          caCertificate: base64-encoded string

      - type: MARIADB
        config:
          host: string
          port: integer, default: 3306
          username: string
        secrets:
          password: string

      - type: MSSQL
        config:
          host: string
          port: integer, default: 1433
          username: string
          database: string
        secrets:
         password: string

      - type: MYSQL
        config:
          host: string
          port: integer, default: 3306
          username: string
        secrets:
          password: string

      - type: ORACLE
        config:
          host: string
          port: integer, default: 1521
          username: string
          connectionType: enum {SID, SERVICE_NAME}, default: SID
          database: string, default: ORCL
        secrets:
          password: string

      - type: POSTGRES
        config:
          host: string
          port: integer, default: 5432
          username: string
          database: string
          sslEnabled: boolean, default: false
        secrets:
          password: string
        ssl:
          rootCertificate: base64-encoded string
          sslCertificate: base64-encoded string
          sslCertificateKey: base64-encoded string

      - type: SNOWFLAKE
        config:
          account: string
          username: string
          warehouse: string, default: COMPUTE_WH
          database: string
        secrets:
          password: string
      ```

    """

    name: Annotated[Optional[str], Field(description="The name of a connector.")] = None
    type: ConnectorType
    access_type: Annotated[Optional[ConnectorAccessType], Field(alias="accessType")] = (
        "SOURCE"
    )
    config: Optional[Dict[str, Any]] = None
    secrets: Optional[Dict[str, str]] = None
    ssl: Optional[Dict[str, str]] = None


class ConnectorPatchConfig(CustomBaseModel):
    """
    See ConnectorConfig for details on the structure of the connection parameters.

    """

    name: Annotated[Optional[str], Field(description="The name of a connector.")] = None
    config: Optional[Dict[str, Any]] = None
    secrets: Optional[Dict[str, str]] = None
    ssl: Optional[Dict[str, str]] = None


class GeneratorUsage(CustomBaseModel):
    """
    Usage statistics of a generator.
    """

    total_datapoints: Annotated[
        Optional[int],
        Field(
            alias="totalDatapoints",
            description="The total number of datapoints generated by this generator.",
        ),
    ] = None
    total_compute_time: Annotated[
        Optional[int],
        Field(
            alias="totalComputeTime",
            description="The total compute time in seconds used for training this generator.\nThis is the sum of the compute time of all trained tasks.\n",
        ),
    ] = None
    no_of_synthetic_datasets: Annotated[
        Optional[int],
        Field(
            alias="noOfSyntheticDatasets",
            description="Number of synthetic datasets generated by this generator.",
        ),
    ] = None
    no_of_shares: Annotated[
        Optional[int],
        Field(alias="noOfShares", description="Number of shares of this generator."),
    ] = None
    no_of_likes: Annotated[
        Optional[int],
        Field(alias="noOfLikes", description="Number of likes of this generator."),
    ] = None


class SourceColumnValueRange(CustomBaseModel):
    """
    The (privacy-safe) range of values detected within a source column. These values can then be used as seed values
    for conditional generation. For CATEGORICAL and NUMERIC_DISCRETE encoding types, this will be given as a list
    of unique values, sorted by popularity. For other NUMERIC and for DATETIME encoding types, this will be given
    as a min and max value. Note, that this property will only be populated, once the analysis step for the training
    of the generator has been completed.

    """

    min: Annotated[
        Optional[str],
        Field(
            description="The minimum value of the column. For dates, this is represented in ISO format."
        ),
    ] = None
    max: Annotated[
        Optional[str],
        Field(
            description="The maximum value of the column. For dates, this is represented in ISO format."
        ),
    ] = None
    values: Annotated[
        Optional[List[str]],
        Field(
            description="The list of distinct values of the column. Limited to a maximum of 1000 values."
        ),
    ] = None
    has_null: Annotated[
        Optional[bool],
        Field(description="If true, null value was detected within the column."),
    ] = None


class SourceForeignKey(CustomBaseModel):
    id: Annotated[str, Field(description="The unique identifier of a foreign key.")]
    column: Annotated[
        Optional[str], Field(description="The column name of a foreign key.")
    ] = None
    referenced_table: Annotated[
        str,
        Field(
            alias="referencedTable",
            description="The table name of the referenced table. That table must have a primary key already defined.",
        ),
    ]
    is_context: Annotated[
        bool,
        Field(
            alias="isContext",
            description="If true, then the foreign key will be considered as a context relation.\nNote, that only one foreign key relation per table can be a context relation.\n",
        ),
    ]


class GeneratorCloneTrainingStatus(Enum):
    """
    The training status of the new generator. The available options are:

    - `NEW`: The new generator will re-use existing data and model configurations.
    - `CONTINUE`: The new generator will re-use existing data and model configurations, as well as model weights.

    """

    new = "NEW"
    continue_ = "CONTINUE"


class GeneratorPatchConfig(CustomBaseModel):
    """
    The configuration for updating a generator.
    """

    name: Annotated[Optional[str], Field(description="The name of a generator.")] = None
    description: Annotated[
        Optional[str], Field(description="The description of a generator.")
    ] = None


class GeneratorImportFromFileConfig(CustomBaseModel):
    file: bytes


class SourceForeignKeyConfig(CustomBaseModel):
    column: Annotated[str, Field(description="The column name of a foreign key.")]
    referenced_table: Annotated[
        str,
        Field(
            alias="referencedTable",
            description="The table name of the referenced table. That table must have a primary key already defined.",
        ),
    ]
    is_context: Annotated[
        Optional[bool],
        Field(
            alias="isContext",
            description="If true, then the foreign key will be considered as a context relation.\nNote, that only one foreign key relation per table can be a context relation.\n",
        ),
    ] = None


class SourceForeignKeyPatchConfig(CustomBaseModel):
    is_context: Annotated[
        Optional[bool],
        Field(
            alias="isContext",
            description="If true, then the foreign key will be considered as a context relation.\nNote, that only one foreign key relation per table can be a context relation.\n",
        ),
    ] = None


class RareCategoryReplacementMethod(str, Enum):
    """
    Specifies, if the rare categories for categoricals will be replaced by a constant
    _RARE_ or by a sample from non-rare categories.
    Only applicable if valueProtection is set to True.

    """

    constant = "CONSTANT"
    sample = "SAMPLE"


class StepCode(str, Enum):
    pull_training_data = "PULL_TRAINING_DATA"
    analyze_training_data = "ANALYZE_TRAINING_DATA"
    encode_training_data = "ENCODE_TRAINING_DATA"
    train_model = "TRAIN_MODEL"
    generate_model_report_data = "GENERATE_MODEL_REPORT_DATA"
    create_model_report = "CREATE_MODEL_REPORT"
    finalize_training = "FINALIZE_TRAINING"
    pull_context_data = "PULL_CONTEXT_DATA"
    generate_data = "GENERATE_DATA"
    create_data_report = "CREATE_DATA_REPORT"
    finalize_generation = "FINALIZE_GENERATION"
    deliver_data = "DELIVER_DATA"


class ProgressValue(CustomBaseModel):
    value: Optional[int] = None
    max: Optional[int] = None


class ProgressStatus(str, Enum):
    """
    The status of a job or a step.

    - `NEW`: The job/step is being configured, and has not started yet
    - `CONTINUE`: The job/step is being configured, but has existing artefacts
    - `ON_HOLD`: The job/step has been started, but is kept on hold
    - `QUEUED`: The job/step has been started, and is awaiting for resources to execute
    - `IN_PROGRESS`: The job/step is currently running
    - `DONE`: The job/step has finished successfully
    - `FAILED`: The job/step has failed
    - `CANCELED`: The job/step has been canceled

    """

    new = "NEW"
    continue_ = "CONTINUE"
    on_hold = "ON_HOLD"
    queued = "QUEUED"
    in_progress = "IN_PROGRESS"
    done = "DONE"
    failed = "FAILED"
    canceled = "CANCELED"


class SyntheticDatasetUsage(CustomBaseModel):
    """
    Usage statistics of a synthetic dataset.
    """

    total_datapoints: Annotated[
        Optional[int],
        Field(
            alias="totalDatapoints",
            description="The number of datapoints in the synthetic dataset",
        ),
    ] = None
    total_credits: Annotated[
        Optional[float],
        Field(
            alias="totalCredits",
            description="The number of credits used for the synthetic dataset",
        ),
    ] = None
    total_compute_time: Annotated[
        Optional[int],
        Field(
            alias="totalComputeTime",
            description="The total compute time in seconds used for generating this synthetic dataset.\nThis is the sum of the compute time of all trained tasks.\n",
        ),
    ] = None
    no_of_shares: Annotated[
        Optional[int],
        Field(
            alias="noOfShares",
            description="Number of shares of this synthetic dataset.",
        ),
    ] = None
    no_of_likes: Annotated[
        Optional[int],
        Field(
            alias="noOfLikes", description="Number of likes of this synthetic dataset."
        ),
    ] = None


class SyntheticDatasetListItem(CustomBaseModel):
    """
    Essential synthetic dataset details for listings.
    """

    id: Annotated[
        str, Field(description="The unique identifier of a synthetic dataset.")
    ]
    metadata: Metadata
    name: Annotated[str, Field(description="The name of a synthetic dataset.")]
    description: Annotated[
        Optional[str], Field(description="The description of a synthetic dataset.")
    ] = None
    generation_status: Annotated[ProgressStatus, Field(alias="generationStatus")]
    generation_time: Annotated[
        Optional[datetime],
        Field(
            alias="generationTime",
            description="The UTC date and time when the generation has finished.",
        ),
    ] = None
    usage: Optional[SyntheticDatasetUsage] = None


class SyntheticDatasetFormat(str, Enum):
    csv = "CSV"
    parquet = "PARQUET"
    xlsx = "XLSX"


class SyntheticDatasetReportType(str, Enum):
    model = "MODEL"
    data = "DATA"


class ForeignKey(CustomBaseModel):
    column: Annotated[str, Field(description="The column name of a foreign key.")]
    referenced_table: Annotated[
        str,
        Field(
            alias="referencedTable",
            description="The table name of the referenced table. That table must have a primary key already defined.",
        ),
    ]
    is_context: Annotated[
        bool,
        Field(
            alias="isContext",
            description="If true, then the foreign key will be considered as a context relation.\nNote, that only one foreign key relation per table can be a context relation.\n",
        ),
    ]


class SyntheticDatasetDelivery(CustomBaseModel):
    overwrite_tables: Annotated[
        bool,
        Field(
            alias="overwriteTables",
            description="If true, tables in the destination will be overwritten.\nIf false, any tables exist, the delivery will fail.\n",
        ),
    ]
    destination_connector_id: Annotated[
        str,
        Field(
            alias="destinationConnectorId",
            description="The unique identifier of a connector.",
        ),
    ]
    location: Annotated[
        str, Field(description="The location for the destination connector.")
    ]


class SyntheticDatasetPatchConfig(CustomBaseModel):
    name: Annotated[
        Optional[str], Field(description="The name of a synthetic dataset.")
    ] = None
    description: Annotated[
        Optional[str], Field(description="The description of a synthetic dataset.")
    ] = None
    delivery: Optional[SyntheticDatasetDelivery] = None


class AssistantLiteLlmExtraItem(CustomBaseModel):
    key: Optional[str] = None
    value: Optional[str] = None


class LiteLlm(CustomBaseModel):
    model: Annotated[
        Optional[str],
        Field(
            description="The LiteLLM model of the assistant. See https://docs.litellm.ai/docs/providers.",
            examples=[["openai/gpt-3.5-turbo", "mistral/mistral-tiny"]],
        ),
    ] = None
    api_key: Annotated[
        Optional[str],
        Field(
            alias="apiKey",
            description="The API key for the selected LiteLLM model. See https://docs.litellm.ai/docs/providers.",
        ),
    ] = None
    extra: Annotated[
        Optional[List[AssistantLiteLlmExtraItem]],
        Field(
            description="Any additional configuration parameters for the selected LiteLLM model. See https://docs.litellm.ai/docs/providers."
        ),
    ] = None


class DataLlm(CustomBaseModel):
    api_key: Annotated[
        Optional[str],
        Field(
            alias="apiKey",
            description="The API key for the DataLLM service. See https://data.mostly.ai.",
        ),
    ] = None


class AssistantSettings(CustomBaseModel):
    """
    Additional optional assistant settings used for LiteLLM
    """

    is_enabled: Annotated[
        Optional[bool],
        Field(alias="isEnabled", description="If true, the assistant is enabled."),
    ] = None
    lite_llm: Annotated[Optional[LiteLlm], Field(alias="liteLlm")] = None
    data_llm: Annotated[Optional[DataLlm], Field(alias="dataLlm")] = None
    system_instructions: Annotated[
        Optional[str],
        Field(
            alias="systemInstructions",
            description="The system instructions of the assistant",
        ),
    ] = None
    custom_instructions: Annotated[
        Optional[str],
        Field(
            alias="customInstructions",
            description="The custom instructions of the assistant",
        ),
    ] = None
    default_system_instructions: Annotated[
        Optional[str],
        Field(
            alias="defaultSystemInstructions",
            description="The system instructions of the assistant",
        ),
    ] = None


class AssistantThreadSessionStatus(str, Enum):
    initializing = "initializing"
    running = "running"
    expired = "expired"


class AssistantMessageRole(str, Enum):
    """
    The role of the author of this message
    """

    system = "system"
    user = "user"
    assistant = "assistant"
    tool = "tool"
    heartbeat = "heartbeat"


class AssistantMessageContentType(str, Enum):
    """
    The type of the message content
    """

    text = "text"
    python = "python"
    console = "console"
    file = "file"


class AssistantMessageFinishReason(str, Enum):
    stop = "stop"
    length = "length"
    tool_calls = "tool_calls"


class AssistantMessage(CustomBaseModel):
    """
    A complete message.
    """

    id: Annotated[
        Optional[str],
        Field(description="The unique identifier of a assistant message."),
    ] = None
    role: Optional[AssistantMessageRole] = None
    content_type: Annotated[
        Optional[AssistantMessageContentType], Field(alias="contentType")
    ] = None
    content: Annotated[
        Optional[str],
        Field(description="The content of a message", max_length=65000, min_length=0),
    ] = None
    finish_reason: Annotated[
        Optional[AssistantMessageFinishReason], Field(alias="finishReason")
    ] = None
    tokens_consumed: Annotated[
        Optional[int],
        Field(
            alias="tokensConsumed",
            description="The number of tokens consumed by the assistant message.",
        ),
    ] = None


class AssistantMessageDelta(CustomBaseModel):
    """
    A partial message delta generated by streamed model responses.
    """

    id: Annotated[
        Optional[str],
        Field(description="The unique identifier of a assistant message."),
    ] = None
    role: Optional[AssistantMessageRole] = None
    content_type: Annotated[
        Optional[AssistantMessageContentType], Field(alias="contentType")
    ] = None
    delta: Annotated[
        Optional[str],
        Field(
            description="The partial content of a message",
            max_length=65000,
            min_length=1,
        ),
    ] = None
    finish_reason: Annotated[
        Optional[AssistantMessageFinishReason], Field(alias="finishReason")
    ] = None
    tokens_consumed: Annotated[
        Optional[int],
        Field(
            alias="tokensConsumed",
            description="The number of tokens consumed by the model.",
        ),
    ] = None


class AssistantThreadUsage(CustomBaseModel):
    no_of_shares: Annotated[
        Optional[int],
        Field(
            alias="noOfShares", description="Number of shares of this assistant thread."
        ),
    ] = None
    total_tokens_consumed: Annotated[
        Optional[int],
        Field(
            alias="totalTokensConsumed",
            description="The total number of tokens consumed by the thread.",
        ),
    ] = None


class AssistantThreadConfig(CustomBaseModel):
    name: Annotated[
        Optional[str], Field(description="The name of a assistant thread.")
    ] = None


class AssistantThreadPatchConfig(CustomBaseModel):
    name: Annotated[
        Optional[str], Field(description="The name of a assistant thread.")
    ] = None


class AssistantMessageConfig(CustomBaseModel):
    """
    Submit a new message
    """

    stream: Annotated[
        Optional[bool],
        Field(
            description="Whether to stream back partial progress. If set, message deltas will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a data: [DONE] message."
        ),
    ] = True
    content: Annotated[
        Optional[str],
        Field(description="The content of a message", max_length=65000, min_length=0),
    ] = None
    content_type: Annotated[
        Optional[AssistantMessageContentType], Field(alias="contentType")
    ] = None


class ComputeType(str, Enum):
    """
    The type of compute.
    """

    kubernetes = "KUBERNETES"
    databricks = "DATABRICKS"


class ComputeResources(CustomBaseModel):
    """
    A set of available hardware resources for a compute resource.
    """

    cpus: Annotated[Optional[int], Field(description="The number of CPU cores")] = None
    memory: Annotated[
        Optional[float], Field(description="The amount of memory in GB")
    ] = None
    gpus: Annotated[Optional[int], Field(description="The number of GPUs")] = 0
    gpu_memory: Annotated[
        Optional[float],
        Field(alias="gpuMemory", description="The amount of GPU memory in GB"),
    ] = 0


class ComputeListItem(CustomBaseModel):
    """
    Essential compute details for listings.
    """

    id: Optional[str] = None
    type: Optional[ComputeType] = None
    name: Optional[str] = None
    resources: Optional[ComputeResources] = None


class Compute(CustomBaseModel):
    """
    A compute resource for executing tasks.
    """

    id: Optional[str] = None
    name: Optional[str] = None
    type: Optional[ComputeType] = None
    config: Optional[Dict[str, Any]] = None
    secrets: Optional[Dict[str, Any]] = None
    resources: Optional[ComputeResources] = None
    order_index: Annotated[
        Optional[int],
        Field(
            alias="orderIndex",
            description="The index for determining the sort order when listing computes",
        ),
    ] = None


class ComputeConfig(CustomBaseModel):
    """
    The configuration for creating a new compute resource.
    """

    name: Optional[str] = None
    type: Optional[ComputeType] = None
    resources: Optional[ComputeResources] = None
    config: Optional[Dict[str, Any]] = None
    secrets: Optional[Dict[str, Any]] = None
    order_index: Annotated[
        Optional[int],
        Field(
            alias="orderIndex",
            description="The index for determining the sort order when listing computes",
        ),
    ] = None


class ComputePatchConfig(CustomBaseModel):
    name: Optional[str] = None
    type: Optional[ComputeType] = None
    resources: Optional[ComputeResources] = None
    config: Optional[Dict[str, Any]] = None
    secrets: Optional[Dict[str, Any]] = None
    order_index: Annotated[
        Optional[int],
        Field(
            alias="orderIndex",
            description="The index for determining the sort order when listing computes",
        ),
    ] = None


class UsageReportPeriod(CustomBaseModel):
    """
    The usage report for a specific month
    """

    period_start: Annotated[
        Optional[datetime],
        Field(
            alias="periodStart",
            description="The UTC date and time when the reported time period started",
        ),
    ] = None
    period_end: Annotated[
        Optional[datetime],
        Field(
            alias="periodEnd",
            description="The UTC date and time when the reported time period started",
        ),
    ] = None
    total_datapoints: Annotated[
        Optional[int],
        Field(
            alias="totalDatapoints",
            description="The number of datapoints generated during the reported period",
        ),
    ] = None
    total_rows: Annotated[
        Optional[int],
        Field(
            alias="totalRows",
            description="The number of rows generated during the reported period",
        ),
    ] = None
    total_credits: Annotated[
        Optional[float],
        Field(
            alias="totalCredits",
            description="The number of credits used during the reported period",
        ),
    ] = None


class ModelType(str, Enum):
    """
    The type of model.

    - `TABULAR`: A generative AI model tailored towards tabular data, trained from scratch.
    - `LANGUAGE`: A generative AI model build upon a (pre-trained) language model.

    """

    tabular = "TABULAR"
    language = "LANGUAGE"


class ModelEncodingType(str, Enum):
    """
    The encoding type used for model training and data generation.

    - `AUTO`: Model chooses among available encoding types based on the column's data type.
    - `TABULAR_CATEGORICAL`: Model samples from existing (non-rare) categories.
    - `TABULAR_NUMERIC_AUTO`: Model chooses among 3 numeric encoding types based on the values.
    - `TABULAR_NUMERIC_DISCRETE`: Model samples from existing discrete numerical values.
    - `TABULAR_NUMERIC_BINNED`: Model samples from binned buckets, to then sample randomly within a bucket.
    - `TABULAR_NUMERIC_DIGIT`: Model samples each digit of a numerical value.
    - `TABULAR_CHARACTER`: Model samples each character of a string value.
    - `TABULAR_DATETIME`: Model samples each part of a datetime value.
    - `TABULAR_DATETIME_RELATIVE`: Model samples the relative difference between datetimes within a sequence.
    - `TABULAR_LAT_LONG`: Model samples a latitude-longitude column. The format is "latitude,longitude".
    - `LANGUAGE_TEXT`: Model will train a distinct LANGUAGE model for this column, to then generate free text.

    Encoding types, that are not being prefixed with either `TABULAR` or `LANGUAGE` have been deprecated.

    """

    auto = "AUTO"
    tabular_categorical = "TABULAR_CATEGORICAL"
    tabular_numeric_auto = "TABULAR_NUMERIC_AUTO"
    tabular_numeric_discrete = "TABULAR_NUMERIC_DISCRETE"
    tabular_numeric_binned = "TABULAR_NUMERIC_BINNED"
    tabular_numeric_digit = "TABULAR_NUMERIC_DIGIT"
    tabular_character = "TABULAR_CHARACTER"
    tabular_datetime = "TABULAR_DATETIME"
    tabular_datetime_relative = "TABULAR_DATETIME_RELATIVE"
    tabular_lat_long = "TABULAR_LAT_LONG"
    language_text = "LANGUAGE_TEXT"


class RebalancingConfig(CustomBaseModel):
    """
    Configure rebalancing.
    """

    column: Annotated[
        str,
        Field(
            description="The name of the column to be rebalanced.  Only applicable for a subject table.\nOnly applicable for categorical columns.\n"
        ),
    ]
    probabilities: Annotated[
        Dict[str, float],
        Field(
            description="The target distribution of samples values.\nThe keys are the categorical values, and the values are the probabilities.\n",
            examples=[[{"US": 0.8}, {"male": 0.5, "female": 0.5}]],
        ),
    ]


class ImputationConfig(CustomBaseModel):
    """
    Configure imputation.
    """

    columns: Annotated[
        List[str],
        Field(
            description="The names of the columns to be imputed.\nImputed columns will suppress the sampling of NULL values.\n"
        ),
    ]


class FairnessConfig(CustomBaseModel):
    """
    Configure a fairness objective for the table.
    Only applicable for a subject table.
    The generated synthetic data will maintain robust statistical parity between the target column and
    the specified sensitive columns. All these columns must be categorical.

    """

    target_column: Annotated[
        str, Field(alias="targetColumn", description="The name of the target column.")
    ]
    sensitive_columns: Annotated[
        List[str],
        Field(
            alias="sensitiveColumns", description="The names of the sensitive columns."
        ),
    ]


class DifferentialPrivacyConfig(CustomBaseModel):
    """
    The optional differential privacy configuration for training the model.
    If not provided, then no differential privacy will be applied.

    """

    max_epsilon: Annotated[
        Optional[float],
        Field(
            alias="maxEpsilon",
            description="Specifies the maximum allowable epsilon value. If the training process exceeds this threshold, it will be terminated early. Only model checkpoints with epsilon values below this limit will be retained. \nIf not provided, the training will proceed without early termination based on epsilon constraints.\n",
            ge=0.0,
            le=10000.0,
        ),
    ] = None
    noise_multiplier: Annotated[
        Optional[float],
        Field(
            alias="noiseMultiplier",
            description="The ratio of the standard deviation of the Gaussian noise to the L2-sensitivity of the function to which the noise is added (How much noise to add).\n",
            ge=0.0,
            le=10000.0,
        ),
    ] = 1.5
    max_grad_norm: Annotated[
        Optional[float],
        Field(
            alias="maxGradNorm",
            description="The maximum norm of the per-sample gradients for training the model with differential privacy.\n",
            ge=0.0,
            le=10000.0,
        ),
    ] = 1.0


class Accuracy(CustomBaseModel):
    """
    Metrics regarding the accuracy of synthetic data, measured as the closeness of discretized lower dimensional
    marginal distributions.

    1. **Univariate Accuracy**: The accuracy of the univariate distributions for all target columns.
    2. **Bivariate Accuracy**: The accuracy of all pair-wise distributions for target columns, as well as for target
    columns with respect to the context columns.
    3. **Coherence Accuracy**: The accuracy of the auto-correlation for all target columns.

    Accuracy is defined as 100% - [Total Variation Distance](https://en.wikipedia.org/wiki/Total_variation_distance_of_probability_measures) (TVD),
    whereas TVD is half the sum of the absolute differences of the relative frequencies of the corresponding
    distributions.

    These accuracies are calculated for all discretized univariate, and bivariate distributions. In case of sequential
    data, also for all coherence distributions. Overall metrics are then calculated as the average across these
    accuracies.

    All metrics can be compared against a theoretical maximum accuracy, which is calculated for a same-sized holdout.
    The accuracy metrics shall be as close as possible to the theoretical maximum, but not significantly higher, as
    this would indicate overfitting.

    """

    overall: Annotated[
        Optional[float],
        Field(
            description="Overall accuracy of synthetic data, averaged across univariate, bivariate, and coherence.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    univariate: Annotated[
        Optional[float],
        Field(
            description="Average accuracy of discretized univariate distributions.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    bivariate: Annotated[
        Optional[float],
        Field(
            description="Average accuracy of discretized bivariate distributions.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    coherence: Annotated[
        Optional[float],
        Field(
            description="Average accuracy of discretized coherence distributions. Only applicable for sequential data.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    overall_max: Annotated[
        Optional[float],
        Field(
            alias="overallMax",
            description="Expected overall accuracy of a same-sized holdout. Serves as a reference for `overall`.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    univariate_max: Annotated[
        Optional[float],
        Field(
            alias="univariateMax",
            description="Expected univariate accuracy of a same-sized holdout. Serves as a reference for `univariate`.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    bivariate_max: Annotated[
        Optional[float],
        Field(
            alias="bivariateMax",
            description="Expected bivariate accuracy of a same-sized holdout. Serves as a reference for `bivariate`.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    coherence_max: Annotated[
        Optional[float],
        Field(
            alias="coherenceMax",
            description="Expected coherence accuracy of a same-sized holdout. Serves as a reference for `coherence`.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None


class Similarity(CustomBaseModel):
    """
    Metrics regarding the similarity of the full joint distributions of samples within an embedding space.

    1. **Cosine Similarity**: The cosine similarity between the centroids of synthetic and training samples.
    2. **Discriminator AUC**: The AUC of a discriminative model to distinguish between synthetic and training samples.

    The SentenceTransformer model [all-MiniLM-L6-v2](https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2) is
    used to compute the embeddings of a string-ified representation of individual records. In case of sequential data
    the records, that belong to the same group, are being concatenated. We then calculate the cosine similarity
    between the centroids of the provided datasets within the embedding space.

    Again, we expect the similarity metrics to be as close as possible to 1, but not significantly higher than what is
    measured for the holdout data, as this would again indicate overfitting.

    In addition, a discriminative ML model is trained to distinguish between training and synthetic samples. The
    ability of this model to distinguish between training and synthetic samples is measured by the AUC score. For
    synthetic data to be considered realistic, the AUC score should be close to 0.5, which indicates that the synthetic
    data is indistinguishable from the training data.

    """

    cosine_similarity_training_synthetic: Annotated[
        Optional[float],
        Field(
            alias="cosineSimilarityTrainingSynthetic",
            description="Cosine similarity between training and synthetic centroids.",
            ge=-1.0,
            le=1.0,
        ),
    ] = None
    cosine_similarity_training_holdout: Annotated[
        Optional[float],
        Field(
            alias="cosineSimilarityTrainingHoldout",
            description="Cosine similarity between training and holdout centroids. Serves as a reference for `cosine_similarity_training_synthetic`.",
            ge=-1.0,
            le=1.0,
        ),
    ] = None
    discriminator_auc_training_synthetic: Annotated[
        Optional[float],
        Field(
            alias="discriminatorAUCTrainingSynthetic",
            description="Cross-validated AUC of a discriminative model to distinguish between training and synthetic samples.",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    discriminator_auc_training_holdout: Annotated[
        Optional[float],
        Field(
            alias="discriminatorAUCTrainingHoldout",
            description="Cross-validated AUC of a discriminative model to distinguish between training and holdout samples. Serves as a reference for `discriminator_auc_training_synthetic`.",
            ge=0.0,
            le=1.0,
        ),
    ] = None


class Distances(CustomBaseModel):
    """
    Metrics regarding the nearest neighbor distances between training, holdout, and synthetic samples in an embedding
    space. Useful for assessing the novelty / privacy of synthetic data.

    The provided data is first down-sampled, so that the number of samples match across all datasets. Note, that for
    an optimal sensitivity of this privacy assessment it is recommended to use a 50/50 split between training and
    holdout data, and then generate synthetic data of the same size.

    The embeddings of these samples are then computed, and the L2 nearest neighbor distances are calculated for each
    synthetic sample to the training and holdout samples. Based on these nearest neighbor distances the following
    metrics are calculated:
      - Identical Match Share (IMS): The share of synthetic samples that are identical to a training or holdout sample.
      - Distance to Closest Record (DCR): The average distance of synthetic to training or holdout samples.

    For privacy-safe synthetic data we expect to see about as many identical matches, and about the same distances
    for synthetic samples to training, as we see for synthetic samples to holdout.

    """

    ims_training: Annotated[
        Optional[float],
        Field(
            alias="imsTraining",
            description="Share of synthetic samples that are identical to a training sample.",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    ims_holdout: Annotated[
        Optional[float],
        Field(
            alias="imsHoldout",
            description="Share of synthetic samples that are identical to a holdout sample. Serves as a reference for `ims_training`.",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    dcr_training: Annotated[
        Optional[float],
        Field(
            alias="dcrTraining",
            description="Average L2 nearest-neighbor distance between synthetic and training samples.",
            ge=0.0,
        ),
    ] = None
    dcr_holdout: Annotated[
        Optional[float],
        Field(
            alias="dcrHoldout",
            description="Average L2 nearest-neighbor distance between synthetic and holdout samples. Serves as a reference for `dcr_training`.",
            ge=0.0,
        ),
    ] = None
    dcr_share: Annotated[
        Optional[float],
        Field(
            alias="dcrShare",
            description="Share of synthetic samples that are closer to a training sample than to a holdout sample. This should not be significantly larger than 50%.",
            ge=0.0,
            le=1.0,
        ),
    ] = None


class BaseResource(CustomBaseModel):
    """
    A set of common properties across resources.
    """

    id: Annotated[
        Optional[str], Field(description="The unique identifier of the entity.")
    ] = None
    name: Annotated[Optional[str], Field(description="The name of the entity.")] = None
    uri: Annotated[
        Optional[str],
        Field(
            description="The API service endpoint of the entity",
            examples=["/generators/94c77249-42bf-443a-8e17-6e18a19d60b8"],
        ),
    ] = None
    current_user_permission_level: Annotated[
        Optional[PermissionLevel], Field(alias="currentUserPermissionLevel")
    ] = None
    current_user_like_status: Annotated[
        Optional[bool],
        Field(
            alias="currentUserLikeStatus",
            description="A boolean indicating whether the user has liked the entity or not",
        ),
    ] = None


class ShareConfig(CustomBaseModel):
    user_email: Annotated[
        str, Field(alias="userEmail", description="The email of a user")
    ]
    permission_level: Annotated[PermissionLevel, Field(alias="permissionLevel")]


class ShareDeleteConfig(CustomBaseModel):
    user_email: Annotated[
        str, Field(alias="userEmail", description="The email of a user")
    ]


class User(CustomBaseModel):
    """
    A user of the service.
    """

    id: Annotated[
        Optional[str], Field(description="The unique identifier of a user.")
    ] = None
    first_name: Annotated[
        Optional[str],
        Field(alias="firstName", description="First name of a user", max_length=30),
    ] = None
    last_name: Annotated[
        Optional[str],
        Field(alias="lastName", description="Last name of a user", max_length=30),
    ] = None
    email: Annotated[Optional[str], Field(description="The email of a user")] = None


class CurrentUser(CustomBaseModel):
    """
    Information on the current user.
    """

    id: Annotated[
        Optional[str], Field(description="The unique identifier of a user.")
    ] = None
    first_name: Annotated[
        Optional[str],
        Field(alias="firstName", description="First name of a user", max_length=30),
    ] = None
    last_name: Annotated[
        Optional[str],
        Field(alias="lastName", description="Last name of a user", max_length=30),
    ] = None
    email: Annotated[Optional[str], Field(description="The email of a user")] = None
    settings: Optional[Dict[str, Any]] = None
    usage: Optional[UserUsage] = None
    unread_notifications: Annotated[
        Optional[int],
        Field(
            alias="unreadNotifications",
            description="Number of unread notifications for the user",
        ),
    ] = None


class UserSettingsUpdateConfig(CustomBaseModel):
    """
    The configuration for updating user settings.
    """

    profile: Optional[UserSettingsProfileUpdateConfig] = None
    assistant: Optional[UserSettingsAssistantUpdateConfig] = None


class Notification(CustomBaseModel):
    """
    A notification for a user.
    """

    id: Annotated[str, Field(description="The unique identifier of the notification.")]
    type: NotificationType
    message: Annotated[str, Field(description="The message of the notification.")]
    status: NotificationStatus
    created_at: Annotated[
        datetime,
        Field(
            alias="createdAt",
            description="The UTC date and time when the notification has been created.",
        ),
    ]
    resource_uri: Annotated[
        Optional[str],
        Field(
            alias="resourceUri",
            description="The API service endpoint of the entity",
            examples=["/generators/94c77249-42bf-443a-8e17-6e18a19d60b8"],
        ),
    ] = None


class GeneratorListItem(CustomBaseModel):
    """
    Essential generator details for listings.
    """

    id: Annotated[str, Field(description="The unique identifier of a generator.")]
    name: Annotated[Optional[str], Field(description="The name of a generator.")] = None
    description: Annotated[
        Optional[str], Field(description="The description of a generator.")
    ] = None
    training_status: Annotated[ProgressStatus, Field(alias="trainingStatus")]
    training_time: Annotated[
        Optional[datetime],
        Field(
            alias="trainingTime",
            description="The UTC date and time when the training has finished.",
        ),
    ] = None
    usage: Optional[GeneratorUsage] = None
    metadata: Metadata


class Probe(CustomBaseModel):
    """
    The generated synthetic samples returned as a result of the probe.
    """

    name: Annotated[Optional[str], Field(description="The name of the table.")] = None
    rows: Optional[List[Dict[str, Any]]] = None


class SourceColumn(CustomBaseModel):
    """
    A column as part of a source table.
    """

    id: Annotated[str, Field(description="The unique identifier of a source column.")]
    name: Annotated[str, Field(description="The name of a source column.")]
    included: Annotated[
        bool,
        Field(
            description="If true, the column will be included in the training.\nIf false, the column will be excluded from the training.\n"
        ),
    ]
    model_encoding_type: Annotated[ModelEncodingType, Field(alias="modelEncodingType")]
    value_range: Annotated[
        Optional[SourceColumnValueRange], Field(alias="valueRange")
    ] = None


class GeneratorCloneConfig(CustomBaseModel):
    """
    The configuration for cloning a generator.
    """

    training_status: Annotated[
        Optional[GeneratorCloneTrainingStatus], Field(alias="trainingStatus")
    ] = "NEW"


class SourceColumnConfig(CustomBaseModel):
    """
    The configuration for a source column when creating a new generator.
    """

    name: Annotated[str, Field(description="The name of a source column.")]
    model_encoding_type: Annotated[
        Optional[ModelEncodingType], Field(alias="modelEncodingType")
    ] = "AUTO"


class SourceColumnPatchConfig(CustomBaseModel):
    """
    The configuration for updating a source column.
    """

    included: Annotated[
        Optional[bool],
        Field(
            description="If true, the column will be included in the training.\nIf false, the column will be excluded from the training.\n"
        ),
    ] = None
    model_encoding_type: Annotated[
        Optional[ModelEncodingType], Field(alias="modelEncodingType")
    ] = "AUTO"


class ModelConfiguration(CustomBaseModel):
    """
    The training configuration for the model
    """

    model: Annotated[
        Optional[str],
        Field(
            description="The model to be used for training.",
            examples=[
                [
                    "MOSTLY_AI/Small",
                    "MOSTLY_AI/Medium",
                    "MOSTLY_AI/Large",
                    "MOSTLY_AI/LSTMFromScratch-3m",
                    "microsoft/phi-1_5",
                ]
            ],
        ),
    ] = None
    max_sample_size: Annotated[
        Optional[int],
        Field(
            alias="maxSampleSize",
            description="The maximum number of samples to consider for training.\nIf not provided, then all available samples will be taken.\n",
            ge=1,
            le=1000000000,
        ),
    ] = None
    batch_size: Annotated[
        Optional[int],
        Field(
            alias="batchSize",
            description="The batch size used for training the model.\nIf not provided, batchSize will be chosen automatically.\n",
            ge=1,
            le=1000000,
        ),
    ] = None
    max_training_time: Annotated[
        Optional[float],
        Field(
            alias="maxTrainingTime",
            description="The maximum number of minutes to train the model.",
            ge=0.0,
            le=100000.0,
        ),
    ] = 10
    max_epochs: Annotated[
        Optional[float],
        Field(
            alias="maxEpochs",
            description="The maximum number of epochs to train the model.",
            ge=0.0,
            le=100000.0,
        ),
    ] = 100
    max_sequence_window: Annotated[
        Optional[int],
        Field(
            alias="maxSequenceWindow",
            description="The maximum sequence window to consider for training.\nOnly applicable for TABULAR models.\n",
            ge=1,
            le=100000,
        ),
    ] = 100
    enable_flexible_generation: Annotated[
        Optional[bool],
        Field(
            alias="enableFlexibleGeneration",
            description="If true, then the trained generator can be used for rebalancing and imputation.\nOnly applicable for TABULAR models.\n",
        ),
    ] = True
    value_protection: Annotated[
        Optional[bool],
        Field(
            alias="valueProtection",
            description="Defines if Rare Category, Extreme value, or Sequence length protection will be applied.\n",
        ),
    ] = True
    rare_category_replacement_method: Annotated[
        Optional[RareCategoryReplacementMethod],
        Field(
            alias="rareCategoryReplacementMethod",
            description="Specifies, if the rare categories for categoricals will be replaced by a constant\n_RARE_ or by a sample from non-rare categories.\nOnly applicable if valueProtection is set to True.\n",
        ),
    ] = "CONSTANT"
    differential_privacy: Annotated[
        Optional[DifferentialPrivacyConfig], Field(alias="differentialPrivacy")
    ] = None
    compute: Optional[str] = None


class ProgressStep(CustomBaseModel):
    """
    The progress of a step.
    """

    id: Optional[str] = None
    model_label: Annotated[
        Optional[str],
        Field(
            alias="modelLabel",
            description="The unique label for the model, consisting of table name and a suffix for the model type.\nThis will be empty for steps that are not related to a model.\n",
            examples=[["census:tabular", "census:language"]],
        ),
    ] = None
    compute_name: Annotated[Optional[str], Field(alias="computeName")] = None
    restarts: Annotated[
        Optional[int],
        Field(
            description="The number of previous restarts for the corresponding task."
        ),
    ] = None
    step_code: Annotated[Optional[StepCode], Field(alias="stepCode")] = None
    start_date: Annotated[
        Optional[datetime],
        Field(
            alias="startDate",
            description="The UTC date and time when the job has started.\nIf the job has not started yet, then this is None.\n",
            examples=["2024-01-25T12:34:56Z"],
        ),
    ] = None
    end_date: Annotated[
        Optional[datetime],
        Field(
            alias="endDate",
            description="The UTC date and time when the job has ended.\nIf the job is still, then this is None.\n",
            examples=["2024-01-25T12:34:56Z"],
        ),
    ] = None
    messages: Optional[List[Dict[str, Any]]] = None
    error_message: Annotated[Optional[str], Field(alias="errorMessage")] = None
    progress: Optional[ProgressValue] = None
    status: Optional[ProgressStatus] = None


class SyntheticTableConfiguration(CustomBaseModel):
    """
    The sample configuration for a synthetic table
    """

    sample_size: Annotated[
        Optional[int],
        Field(
            alias="sampleSize",
            description="Number of generated samples. Only applicable for subject tables.\nIf neither size nor seed is provided, then the default behavior for Synthetic Datasets is to generate the\nsame size of samples as the original, and the default behavior for Synthetic Datasets is to generate one\nsubject only.\n",
            ge=1,
        ),
    ] = None
    sample_seed_connector_id: Annotated[
        Optional[str],
        Field(
            alias="sampleSeedConnectorId",
            description="The connector id of the seed data for conditional generation.\nOnly applicable for subject tables.\n",
        ),
    ] = None
    sample_seed_dict: Annotated[
        Optional[str],
        Field(
            alias="sampleSeedDict",
            description="The base64-encoded string derived from a json line file containing the specified sample seed data.\n",
        ),
    ] = None
    sample_seed_data: Annotated[
        Optional[str],
        Field(
            alias="sampleSeedData",
            description="The base64-encoded string derived from a Parquet file containing the specified sample seed data.\n",
        ),
    ] = None
    sampling_temperature: Annotated[
        Optional[float],
        Field(
            alias="samplingTemperature",
            description="temperature for sampling",
            ge=0.0,
            le=2.0,
        ),
    ] = None
    sampling_top_p: Annotated[
        Optional[float],
        Field(alias="samplingTopP", description="topP for sampling", ge=0.9, le=1.0),
    ] = None
    rebalancing: Optional[RebalancingConfig] = None
    imputation: Optional[ImputationConfig] = None
    fairness: Optional[FairnessConfig] = None
    tabular_compute: Annotated[Optional[str], Field(alias="tabularCompute")] = None
    language_compute: Annotated[Optional[str], Field(alias="languageCompute")] = None

    @field_validator("sample_seed_dict", mode="before")
    @classmethod
    def validate_dict_before(cls, value):
        return (
            convert_to_base64(value, format="jsonl")
            if isinstance(value, dict)
            else value
        )

    @field_validator("sample_seed_data", mode="before")
    @classmethod
    def validate_data_before(cls, value):
        return convert_to_base64(value) if isinstance(value, pd.DataFrame) else value


class SyntheticTablePatchConfig(CustomBaseModel):
    """
    The configuration for updating a synthetic table.
    """

    configuration: Optional[SyntheticTableConfiguration] = None


class SyntheticTableConfig(CustomBaseModel):
    """
    The configuration for a synthetic table when creating a new synthetic dataset.
    """

    name: Annotated[
        str,
        Field(
            description="The name of a synthetic table. This matches the name of a corresponding SourceTable."
        ),
    ]
    configuration: Optional[SyntheticTableConfiguration] = None


class AssistantThreadListItem(CustomBaseModel):
    """
    Essential assistant thread details for listings.
    """

    id: Annotated[
        str, Field(description="The unique identifier of a assistant thread.")
    ]
    metadata: Metadata
    name: Annotated[
        Optional[str], Field(description="The name of a assistant thread.")
    ] = None
    usage: Optional[AssistantThreadUsage] = None


class AssistantThread(CustomBaseModel):
    """
    A assistant thread.
    """

    id: Annotated[
        Optional[str],
        Field(description="The unique identifier of a assistant thread."),
    ] = None
    metadata: Optional[Metadata] = None
    name: Annotated[
        Optional[str], Field(description="The name of a assistant thread.")
    ] = None
    session_status: Annotated[
        Optional[AssistantThreadSessionStatus], Field(alias="sessionStatus")
    ] = None
    messages: Annotated[
        Optional[List[AssistantMessage]],
        Field(
            description="List of all existing messages, excluding any system message.\nExample:\n  What's the square root of 9?   role: user        type: text\n  ok, I will write some python   role: assistant   type: text\n  r = math.sqrt(9)\\nr            role: assistant   type: python\n  3                              role: tool        type: console\n  The answer is 3!               role: assistant   type: text\n  Plot me a random barplot       role: user        type: text\n  ... plt.savefig() ...          role: assistant   type: python\n  Here is ![img]() ...           role: assistant   type: text\n  Write me a random file         role: user        type: text\n  ... .to_csv() ...              role: assistant   type: python\n  Here is [file]() ...           role: assistant   type: text\n"
        ),
    ] = None
    usage: Optional[AssistantThreadUsage] = None


class ModelMetrics(CustomBaseModel):
    """
    Metrics regarding the quality of synthetic data, measured in terms of accuracy, similarity, and distances.

    1. **Accuracy**: Metrics regarding the accuracy of synthetic data, measured as the closeness of discretized lower
    dimensional marginal distributions.
    2. **Similarity**: Metrics regarding the similarity of the full joint distributions of samples within an embedding
    space.
    3. **Distances**: Metrics regarding the nearest neighbor distances between training, holdout, and synthetic samples
    in an embedding space. Useful for assessing the novelty / privacy of synthetic data.

    The quality of synthetic data is assessed by comparing these metrics to the same metrics of a holdout dataset.
    The holdout dataset is a subset of the original training data, that was not used for training the synthetic data
    generator. The metrics of the synthetic data should be as close as possible to the metrics of the holdout data.

    """

    accuracy: Optional[Accuracy] = None
    distances: Optional[Distances] = None
    similarity: Optional[Similarity] = None


class Share(User):
    permission_level: Annotated[
        Optional[PermissionLevel], Field(alias="permissionLevel")
    ] = None


class ResourceShares(CustomBaseModel):
    is_public: Annotated[Optional[bool], Field(alias="isPublic")] = None
    shares: Optional[List[Share]] = None


class SourceTable(CustomBaseModel):
    """
    A table as part of a generator.
    """

    id: Annotated[str, Field(description="The unique identifier of a source table.")]
    source_connector: Annotated[
        Optional[BaseResource], Field(alias="sourceConnector")
    ] = None
    location: Annotated[
        Optional[str],
        Field(
            description="The location of a source table. Together with the source connector it uniquely\nidentifies a source, and samples data from there.\n"
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="The name of a source table. It must be unique within a generator."
        ),
    ]
    primary_key: Annotated[
        Optional[str],
        Field(alias="primaryKey", description="The column name of the primary key."),
    ] = None
    columns: Annotated[
        List[SourceColumn], Field(description="The columns of this generator table.")
    ]
    foreign_keys: Annotated[
        Optional[List[SourceForeignKey]],
        Field(alias="foreignKeys", description="The foreign keys of a table."),
    ] = None
    model_metrics: Annotated[Optional[ModelMetrics], Field(alias="modelMetrics")] = None
    language_model_metrics: Annotated[
        Optional[ModelMetrics], Field(alias="languageModelMetrics")
    ] = None
    model_configuration: Annotated[
        Optional[ModelConfiguration], Field(alias="modelConfiguration")
    ] = None
    language_model_configuration: Annotated[
        Optional[ModelConfiguration], Field(alias="languageModelConfiguration")
    ] = None
    total_rows: Annotated[
        Optional[int],
        Field(
            alias="totalRows",
            description="The total number of rows in the source table while fetching data for training.\n",
        ),
    ] = None

    def model_qa_report(self):
        if self.client and hasattr(self.client, "model_qa_report"):
            return self.client.model_qa_report(
                generator_id=self.extra_key_values["generator_id"], table_id=self.id
            )

    def model_samples(self, **kwargs):
        if self.client and hasattr(self.client, "model_samples"):
            return self.client.model_qa_report(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                **kwargs,
            )

    def get_column(self, column_id: str):
        if self.client and hasattr(self.client, "get_column"):
            return self.client.get_column(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                column_id=column_id,
            )

    def create_foreign_key(self, **kwargs):
        if self.client and hasattr(self.client, "create_foreign_key"):
            return self.client.create_foreign_key(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                **kwargs,
            )

    def update_foreign_key(self, **kwargs):
        if self.client and hasattr(self.client, "update_foreign_key"):
            return self.client.update_foreign_key(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                **kwargs,
            )

    def delete_foreign_key(self, **kwargs):
        if self.client and hasattr(self.client, "delete_foreign_key"):
            return self.client.delete_foreign_key(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                **kwargs,
            )


class SourceTableConfig(CustomBaseModel):
    """
    The configuration for a source table when creating a new generator.
    """

    name: Annotated[
        str,
        Field(
            description="The name of a source table. It must be unique within a generator."
        ),
    ]
    source_connector_id: Annotated[
        Optional[str],
        Field(
            alias="sourceConnectorId",
            description="The unique identifier of a connector.",
        ),
    ] = None
    location: Annotated[
        Optional[str],
        Field(
            description="The location of a source table. Together with the source connector it uniquely\nidentifies a source, and samples data from there.\n"
        ),
    ] = None
    data: Annotated[
        Optional[str],
        Field(
            description="The base64-encoded string derived from a Parquet file containing the specified source table.\n"
        ),
    ] = None
    model_configuration: Annotated[
        Optional[ModelConfiguration], Field(alias="modelConfiguration")
    ] = None
    language_model_configuration: Annotated[
        Optional[ModelConfiguration], Field(alias="languageModelConfiguration")
    ] = None
    primary_key: Annotated[
        Optional[str],
        Field(alias="primaryKey", description="The column name of the primary key."),
    ] = None
    foreign_keys: Annotated[
        Optional[List[SourceForeignKeyConfig]],
        Field(
            alias="foreignKeys",
            description="The foreign key configurations of this table.",
        ),
    ] = None
    columns: Annotated[
        Optional[List[SourceColumnConfig]],
        Field(description="The column configurations of this table."),
    ] = None

    @field_validator("data", mode="before")
    @classmethod
    def validate_data_before(cls, value):
        return convert_to_base64(value) if isinstance(value, pd.DataFrame) else value


class SourceTablePatchConfig(CustomBaseModel):
    """
    The configuration for updating a source table.
    """

    name: Annotated[
        Optional[str],
        Field(
            description="The name of a source table. It must be unique within a generator."
        ),
    ] = None
    primary_key: Annotated[
        Optional[str],
        Field(alias="primaryKey", description="The column name of the primary key."),
    ] = None
    model_configuration: Annotated[
        Optional[ModelConfiguration], Field(alias="modelConfiguration")
    ] = None
    language_model_configuration: Annotated[
        Optional[ModelConfiguration], Field(alias="languageModelConfiguration")
    ] = None


class SourceTableAddConfig(CustomBaseModel):
    """
    The configuration for adding a new source table to a generator.
    """

    source_connector_id: Annotated[
        str,
        Field(
            alias="sourceConnectorId",
            description="The unique identifier of a connector.",
        ),
    ]
    location: Annotated[
        str,
        Field(
            description="The location of a source table. Together with the source connector it uniquely\nidentifies a source, and samples data from there.\n"
        ),
    ]
    name: Annotated[
        Optional[str],
        Field(
            description="The name of a source table. It must be unique within a generator."
        ),
    ] = None
    include_children: Annotated[
        Optional[bool],
        Field(
            alias="includeChildren",
            description="If true, all tables that are referenced by foreign keys will\nbe included. If false, only the selected table will be included.\n",
        ),
    ] = None
    model_configuration: Annotated[
        Optional[ModelConfiguration], Field(alias="modelConfiguration")
    ] = None
    language_model_configuration: Annotated[
        Optional[ModelConfiguration], Field(alias="languageModelConfiguration")
    ] = None


class JobProgress(CustomBaseModel):
    """
    The progress of a job.
    """

    id: Optional[str] = None
    start_date: Annotated[
        Optional[datetime],
        Field(
            alias="startDate",
            description="The UTC date and time when the job has started.\nIf the job has not started yet, then this is None.\n",
            examples=["2024-01-25T12:34:56Z"],
        ),
    ] = None
    end_date: Annotated[
        Optional[datetime],
        Field(
            alias="endDate",
            description="The UTC date and time when the job has ended.\nIf the job is still, then this is None.\n",
            examples=["2024-01-25T12:34:56Z"],
        ),
    ] = None
    progress: Optional[ProgressValue] = None
    status: Optional[ProgressStatus] = None
    steps: Optional[List[ProgressStep]] = None


class SyntheticTable(CustomBaseModel):
    """
    A synthetic table that will be generated.
    """

    id: Annotated[
        Optional[str], Field(description="The unique identifier of a synthetic table.")
    ] = None
    name: Annotated[
        str,
        Field(
            description="The name of a source table. It must be unique within a generator."
        ),
    ]
    configuration: Optional[SyntheticTableConfiguration] = None
    model_metrics: Annotated[Optional[ModelMetrics], Field(alias="modelMetrics")] = None
    language_model_metrics: Annotated[
        Optional[ModelMetrics], Field(alias="languageModelMetrics")
    ] = None
    foreign_keys: Annotated[
        Optional[List[ForeignKey]],
        Field(alias="foreignKeys", description="The foreign keys of this table."),
    ] = None
    total_rows: Annotated[
        Optional[int],
        Field(
            alias="totalRows",
            description="The total number of rows for that table in the generated synthetic dataset.\n",
        ),
    ] = None
    total_datapoints: Annotated[
        Optional[int],
        Field(
            alias="totalDatapoints",
            description="The total number of datapoints for that table in the generated synthetic dataset.\n",
        ),
    ] = None
    source_table_total_rows: Annotated[
        Optional[int],
        Field(
            alias="sourceTableTotalRows",
            description="The total number of rows in the source table while fetching data for training.\n",
        ),
    ] = None


class SyntheticDatasetConfig(CustomBaseModel):
    """
    The configuration for creating a new synthetic dataset.
    """

    generator_id: Annotated[
        Optional[str],
        Field(alias="generatorId", description="The unique identifier of a generator."),
    ] = None
    name: Annotated[
        Optional[str], Field(description="The name of a synthetic dataset.")
    ] = None
    description: Annotated[
        Optional[str], Field(description="The description of a synthetic dataset.")
    ] = None
    tables: Optional[List[SyntheticTableConfig]] = None
    delivery: Optional[SyntheticDatasetDelivery] = None


class SyntheticProbeConfig(CustomBaseModel):
    """
    The configuration for probing for new synthetic samples.
    """

    generator_id: Annotated[
        Optional[str],
        Field(alias="generatorId", description="The unique identifier of a generator."),
    ] = None
    tables: Optional[List[SyntheticTableConfig]] = None


class Generator(CustomBaseModel):
    """
    A generator is a set models that can generate synthetic data.

    The generator can be trained on one or more source tables. A quality assurance report is generated for each model.

    """

    id: Annotated[str, Field(description="The unique identifier of a generator.")]
    name: Annotated[Optional[str], Field(description="The name of a generator.")] = None
    description: Annotated[
        Optional[str], Field(description="The description of a generator.")
    ] = None
    training_status: Annotated[ProgressStatus, Field(alias="trainingStatus")]
    training_time: Annotated[
        Optional[datetime],
        Field(
            alias="trainingTime",
            description="The UTC date and time when the training has finished.",
        ),
    ] = None
    usage: Optional[GeneratorUsage] = None
    metadata: Metadata
    accuracy: Annotated[
        Optional[float],
        Field(
            description="The overall accuracy of the trained generator.\nThis is the average of the overall accuracy scores of all trained models.\n"
        ),
    ] = None
    tables: Annotated[
        Optional[List[SourceTable]], Field(description="The tables of this generator")
    ] = None
    OPEN_URL_PARTS: ClassVar[list] = ["d", "generators"]
    training: Annotated[Any | None, Field(exclude=True)] = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.training = self.Training(self)

    def update(
        self,
        name: str | None = None,
        description: str | None = None,
    ) -> None:
        """
        Update a generator with specific parameters.

        Args:
            name: The name of the generator.
            description: The description of the generator.
        """
        patch_config = GeneratorPatchConfig(
            name=name,
            description=description,
        )
        self.client._update(
            generator_id=self.id, config=patch_config.model_dump(exclude_none=True)
        )
        self.reload()

    def delete(self) -> None:
        """
        Delete the generator.

        Returns:
            None
        """
        return self.client._delete(generator_id=self.id)

    def config(self) -> GeneratorConfig:
        """
        Retrieve writable generator properties.

        Returns:
            GeneratorConfig: The generator properties as a configuration object.
        """
        return self.client._config(generator_id=self.id)

    def export_to_file(
        self,
        file_path: str | Path | None = None,
    ) -> Path:
        """
        Export generator and save to file.

        Args:
            file_path: The file path to save the generator.

        Returns:
            The path to the saved file.
        """
        bytes, filename = self.client._export_to_file(generator_id=self.id)
        file_path = Path(file_path or ".")
        if file_path.is_dir():
            file_path = file_path / filename
        file_path.write_bytes(bytes)
        return file_path

    def clone(self, training_status: Literal["NEW", "CONTINUE"] = "NEW") -> "Generator":
        """
        Clone the generator.

        Args:
            training_status (Literal["NEW", "CONTINUE"]): The training status of the cloned generator.

        Returns:
            Generator: The cloned generator object.
        """
        return self.client._clone(generator_id=self.id, training_status=training_status)

    class Training:
        def __init__(self, _generator: "Generator"):
            self.generator = _generator

        def start(self) -> None:
            """
            Start training.
            """
            self.generator.client._training_start(self.generator.id)

        def cancel(self) -> None:
            """
            Cancel training.
            """
            self.generator.client._training_cancel(self.generator.id)
            self.generator.reload()

        def progress(self) -> JobProgress:
            """
            Retrieve job progress of training.

            Returns:
                JobProgress: The job progress of the training process.
            """
            return self.generator.client._training_progress(self.generator.id)

        def wait(self, progress_bar: bool = True, interval: float = 2) -> None:
            """
            Poll training progress and loop until training has completed.

            Args:
                progress_bar: If true, displays the progress bar.
                interval: The interval in seconds to poll the job progress.
            """
            self.generator.client._training_wait(
                self.generator.id, progress_bar=progress_bar, interval=interval
            )
            self.generator.reload()


class GeneratorConfig(CustomBaseModel):
    """
    The configuration for creating a new generator.
    """

    name: Annotated[Optional[str], Field(description="The name of a generator.")] = None
    description: Annotated[
        Optional[str], Field(description="The description of a generator.")
    ] = None
    tables: Annotated[
        Optional[List[SourceTableConfig]],
        Field(description="The tables of a generator"),
    ] = None


class SyntheticDataset(CustomBaseModel):
    """
    A synthetic dataset is created based on a trained generator.

    It consists of synthetic samples, as well as a quality assurance report.

    """

    id: Annotated[
        str, Field(description="The unique identifier of a synthetic dataset.")
    ]
    generator: Optional[BaseResource] = None
    metadata: Metadata
    name: Annotated[str, Field(description="The name of a synthetic dataset.")]
    description: Annotated[
        Optional[str], Field(description="The description of a synthetic dataset.")
    ] = None
    generation_status: Annotated[ProgressStatus, Field(alias="generationStatus")]
    generation_time: Annotated[
        Optional[datetime],
        Field(
            alias="generationTime",
            description="The UTC date and time when the generation has finished.",
        ),
    ] = None
    tables: Annotated[
        Optional[List[SyntheticTable]],
        Field(description="The tables of this synthetic dataset."),
    ] = None
    delivery: Optional[SyntheticDatasetDelivery] = None
    accuracy: Annotated[
        Optional[float],
        Field(
            description="The overall accuracy of the trained generator.\nThis is the average of the overall accuracy scores of all trained models.\n"
        ),
    ] = None
    usage: Optional[SyntheticDatasetUsage] = None
    OPEN_URL_PARTS: ClassVar[list] = ["d", "synthetic-datasets"]
    generation: Annotated[Any | None, Field(exclude=True)] = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.generation = self.Generation(self)

    def update(
        self,
        name: str | None = None,
        description: str | None = None,
        delivery: SyntheticDatasetDelivery | None = None,
    ) -> None:
        """
        Update a synthetic dataset with specific parameters.

        Args:
            name: The name of the synthetic dataset.
            description: The description of the synthetic dataset.
            delivery: The delivery configuration for the synthetic dataset.
        """
        patch_config = SyntheticDatasetPatchConfig(
            name=name,
            description=description,
            delivery=delivery,
        )
        self.client._update(
            synthetic_dataset_id=self.id,
            config=patch_config.model_dump(exclude_none=True),
        )
        self.reload()

    def delete(self) -> None:
        """
        Delete the synthetic dataset.

        Returns:
            None
        """
        return self.client._delete(synthetic_dataset_id=self.id)

    def config(self) -> SyntheticDatasetConfig:
        """
        Retrieve writable synthetic dataset properties.

        Returns:
            SyntheticDatasetConfig: The synthetic dataset properties as a configuration object.
        """
        return self.client._config(synthetic_dataset_id=self.id)

    def download(
        self,
        format: SyntheticDatasetFormat = "PARQUET",
        file_path: str | Path | None = None,
    ) -> Path:
        """
        Download synthetic dataset and save to file.

        Args:
            format: The format of the synthetic dataset.
            file_path: The file path to save the synthetic dataset.

        Returns:
            The path to the saved file.
        """
        bytes, filename = self.client._download(
            synthetic_dataset_id=self.id,
            ds_format=format,
            short_lived_file_token=self.metadata.short_lived_file_token,
        )
        file_path = Path(file_path or ".")
        if file_path.is_dir():
            file_path = file_path / filename
        file_path.write_bytes(bytes)
        return file_path

    def data(
        self, return_type: Literal["auto", "dict"] = "auto"
    ) -> pd.DataFrame | dict[str, pd.DataFrame]:
        """
        Download synthetic dataset and return as dictionary of pandas DataFrames.

        Args:
            return_type: The format of the returned data.

        Returns:
            The synthetic dataset as a dictionary of pandas DataFrames.
        """
        dfs = self.client._data(
            synthetic_dataset_id=self.id,
            short_lived_file_token=self.metadata.short_lived_file_token,
        )
        if return_type == "auto" and len(dfs) == 1:
            return list(dfs.values())[0]
        else:
            return dfs

    class Generation:
        def __init__(self, _synthetic_dataset: "SyntheticDataset"):
            self.synthetic_dataset = _synthetic_dataset

        def start(self) -> None:
            """
            Start the generation process.
            """
            self.synthetic_dataset.client._generation_start(self.synthetic_dataset.id)

        def cancel(self) -> None:
            """
            Cancel the generation process.
            """
            self.synthetic_dataset.client._generation_cancel(self.synthetic_dataset.id)
            self.synthetic_dataset.reload()

        def progress(self) -> JobProgress:
            """
            Retrieve the progress of the generation process.

            Returns:
                JobProgress: The progress of the generation process.
            """
            return self.synthetic_dataset.client._generation_progress(
                self.synthetic_dataset.id
            )

        def wait(self, progress_bar: bool = True, interval: float = 2) -> None:
            """
            Poll the generation progress and wait until the process is complete.

            Args:
                progress_bar: If true, displays a progress bar.
                interval: Interval in seconds to poll the job progress.
            """
            self.synthetic_dataset.client._generation_wait(
                self.synthetic_dataset.id, progress_bar=progress_bar, interval=interval
            )
            self.synthetic_dataset.reload()
